#!/usr/bin/env python
#
# lwang:  diffit as in *it
#
#
# sample run:
#
# http://svn.corp.foobar.com:8070/svn/lirepo/itops/branches/CONFIG_R1040/
#
# Assumptions:
#	* branch names are named as: CONFIG_Rnnnn, e.g., CONFIG_R1040 for non-prod envs
#	* branch names are named as: PROD_Rnnnn, e.g., PROD_R1046 for prod envs
#	* branches are created in lirepo/itops/branches
#
from __future__ import with_statement
import sys
import os
import re
import subprocess
from optparse import OptionParser
from socket import gethostname
import atexit
import shutil
import urllib

url_root = 'svn+ssh://svn.corp.foobar.com/secure/siteops/ccs/branches'
url_to_current_daily_release_txt = 'http://svn.corp.foobar.com/lirepo/itops/trunk/ccs/bin/CURRENT_DAILY_RELEASE.txt'

if os.uname()[0] == 'SunOS':
  ssh = '/bin/ssh -q '
  sudo = '/usr/local/bin/sudo'
  rsync = '/usr/local/bin/rsync -q -az '
  svn = '/usr/local/bin/svn'
elif os.uname()[0] == 'Darwin' or os.uname()[0] == 'Linux':
  ssh = '/usr/bin/ssh -q '
  sudo = '/usr/bin/sudo'
  rsync = '/usr/bin/rsync -essh --rsync-path=/usr/local/bin/rsync  -q -az '
  svn = '/usr/bin/svn'
else:
  print >>sys.stderr, "Sorry, your platform is not currently supported yet."
  sys.exit(1)


bindir = os.path.join( os.environ['ITOPS_HOME'], 'ccs/bin' )
sys.path.append( bindir )
from foobar.ccs15.env import Env


def get_list_of_limited_rels(ssh,  ccs_host, ccs_dir_root ):
  """
  get a list of limited rels, e.g., 0.0.[987]*
  """
  cmd = "%s %s ' cd  %s; find . -name \"0.0.[987]*\" | sed -e \"s/.*\///\" | sort -u  '  " % (ssh,  ccs_host, ccs_dir_root )
  if debug:
    print "Running cmd: " + cmd

  p = subprocess.Popen([ cmd ], shell=True, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
  out = p.communicate()[0]
  if not out.split() == None:
    return out.split()
  else:
    return None


def get_list_of_rels(ssh,  ccs_host, ccs_dir_root, ccs_app_name ):
  cmd = "%s %s ' ls %s/%s '   " % (ssh,  ccs_host, ccs_dir_root, ccs_app_name )
  if debug:
    print "cmd: " + cmd

  p = subprocess.Popen([ cmd ], shell=True, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
  out = p.communicate()[0]
  if not out.split() == None:
    return out.split()
  else:
    return None


def get_diff_of_list( l1, l2 ):
  """
  get the diff of lists l1 and l2:  l1 - l2
  """
  d = set(l1) - set(l2)
  l = list(d)
  l.sort()
  return l


def get_final_list( list ):
  """ 
  remove non 0.0.xxx items
  """
  final_list = [ item for item in list if '0.0.' in item ]
  return final_list


def run_cmd( cmd ):
  if debug:
    print "running cmd: " + cmd
  try:
    retcode = subprocess.call( " %s " % cmd, shell=True )
    if retcode < 0:
      print >>sys.stderr, "Child was terminated by signal", -retcode      
  except OSError, e:
    print >>sys.stderr, "Execution failed: ", e



def get_latest_ver_in_ccs(ssh, sudo, ccs_host, ccs_dir_root, ccs_app_name, options):
  list_of_rels = get_list_of_rels(ssh,  ccs_host, ccs_dir_root, ccs_app_name)
  if len(list_of_rels) == 0:
    print >>sys.stderr,  'I did not find any existing rel numbers for %s... might be a new service?' % ccs_app_name
#    sys.exit(1)
  else:
    if debug:
      print "list_of_rels: " + str(list_of_rels)


  list_of_limited_rels = get_list_of_limited_rels(ssh,  ccs_host, ccs_dir_root )
  if debug:
    print "list_of_limited_rels: " + str(list_of_limited_rels )

  if options.release.lower() == 'trunk':
    list_of_rels_diff =  list_of_rels
  else:
    list_of_rels_diff = get_diff_of_list( list_of_rels, list_of_limited_rels )
  if debug:
    print "list_of_rels_diff: " + str(list_of_rels_diff)

  list_of_rels_final = get_final_list( list_of_rels_diff )
  if debug:
    print "list_of_rels_final: " + str(list_of_rels_final)

  latest_ver_in_ccs = None

  list_of_rels_final_stems = [  x.split('.')[2]   for x in list_of_rels_final ]

  if list_of_rels_final_stems:
    latest_ver_in_ccs = max(list_of_rels_final_stems, key=int)

  if options.debug:
    if latest_ver_in_ccs:
      print "latest_ver_in_ccs: " + latest_ver_in_ccs

  return latest_ver_in_ccs


def get_latest_ver_in_repo( workdir, ccsappname, options  ):
  latest_ver_in_repo = None
  path_to_latest_file = None

#  if options.release == 'R1040':
#    path_to_latest_file = os.path.join( workdir, ccsappname, 'LATEST')
#  else:
#    path_to_latest_file = os.path.join( workdir, 'config', ccsappname, 'LATEST')

  # Assuming branch convention is followed starting from R1040:  itops/branches/CONFIG_Rxxxx/
  path_to_latest_file = os.path.join( workdir, ccsappname, 'LATEST')

  if os.path.isfile(path_to_latest_file):
    if options.debug:
      print "path to latest file: " + path_to_latest_file
    latest_ver_in_repo = open( path_to_latest_file, 'r').read().rstrip()
  else:
    print >>sys.stderr, "WARNING: No LATEST file found for %s in %s." % ( ccsappname, workdir )
     
  if options.debug:
    if latest_ver_in_repo:
      print "latest_ver_in_repo: " +  latest_ver_in_repo

  return latest_ver_in_repo
  


def make_workdir_root():
  workdir_root = os.path.join( os.environ['HOME'], '.diffit');
  if not os.path.isdir(workdir_root):
    os.mkdir(workdir_root)
  container_dir = os.path.join(workdir_root, 'container')
  if not os.path.isdir(container_dir):
    os.mkdir(container_dir)
  return workdir_root

def create_workdir( release, svn, ccs_dir_root, options ):
  workdir_root = make_workdir_root()

  # if limited or monolithic release, use the -r specified
  if options.limited or options.monolithic:
    release = options.release

  work_url = url_root + '/' + 'CONFIG_' + release
  workdir = workdir_root + '/' + 'CONFIG_' + release
  env =  Env(options.envname)
  if env.is_prod_env():
    work_url = url_root + '/' + 'PROD_' + release
    workdir = workdir_root + '/' + 'PROD_' + release

  if os.path.isdir(workdir):
    shutil.rmtree(workdir)

  # remove dust from previous runs
  container_dir_in_workarea = os.path.join(workdir_root, 'container')
  if os.path.isdir(container_dir_in_workarea):
    shutil.rmtree(container_dir_in_workarea)

  if options.ccsappname:
    cmd_export_from = " %s/%s " % (work_url, options.ccsappname)
    cmd_export_to = " %s/%s " % (workdir, options.ccsappname)
  elif options.toplevel:
    ccs_dir_root_suffix = ccs_dir_root.split('/')[-1]
    cmd_export_from = " %s/%s " % (work_url, ccs_dir_root_suffix)
    cmd_export_to = " %s/%s " % (workdir, ccs_dir_root_suffix)
  else:
    cmd_export_from = " %s " % (work_url)
    cmd_export_to = " %s " % (workdir)

  cmd_export = " %s export %s %s >/dev/null" % (svn, cmd_export_from, cmd_export_to)
  
  if options.debug:
    print "INFO: Running cmd: %s " % cmd_export
  if options.verbose:
    print "INFO: exporting into %s from %s " % (cmd_export_to, cmd_export_from)
  run_cmd( cmd_export )
  
  if options.ccsappname:
    # always export top-level extservices.springconfig and injected.properties
    # /export/content/repository/EI1  -> EI1
    ccs_dir_root_suffix = ccs_dir_root.split('/')[-1]  
    cmd = " %s export %s/%s  %s/%s >/dev/null" % (svn, work_url, ccs_dir_root_suffix, workdir, ccs_dir_root_suffix)
    run_cmd(cmd)
  
  return workdir


def doit_for_toplevel(release, svn, workdir,  ssh, rsync,  ccs_host, ccs_dir_root, options):
  """ including: top-level extservices.springconfig and injected.properties """
  ccs_dir_root_suffix = ccs_dir_root.split('/')[-1]
  toplevel_files = ( 'extservices.springconfig', 'injected.properties' )

  workdir_root = make_workdir_root()

  # pull from ccs, their counterparts in repo are already done in create_workdir()
  for filename in toplevel_files:
    cmd = "%s  %s:%s/%s  %s/%s 2>/dev/null " % ( rsync, ccs_host, ccs_dir_root, filename,  workdir_root, filename )
    if options.debug:
      print "INFO: running cmd: %s" % cmd
    if options.verbose:
      print "INFO: pulling %s from %s:%s" % (filename, ccs_host, ccs_dir_root)
    run_cmd( cmd )

  for filename in toplevel_files: 
    file_in_repo = "%s/%s/%s" % (workdir, ccs_dir_root_suffix, filename)
    file_in_ccs = "%s/%s" % (workdir_root, filename)
    cmd_diff = "diff -w  %s %s " % (file_in_repo, file_in_ccs)
    if options.debug:
      print "INFO: running cmd: %s" % cmd_diff
    if options.verbose:
      print "INFO: diffing %s (repo) with %s (ccs) " % (file_in_repo, file_in_ccs)
    run_cmd(cmd_diff)
   

def doit_for_one(release, svn, workdir,  ssh, sudo,  ccs_host, ccs_dir_root, ccsappname, options):
  """
  handling one ccsappname 
  """
#  latest_ver_in_repo = get_latest_ver_in_repo(workdir, ccsappname, options)
  latest_ver_in_repo = release[1:]

  # handling limited releases
  if options.limited:
    limited_ver_in_repo = latest_ver_in_repo
  
    p = re.compile(r'^[987]\d{2}')
    if not p.match(limited_ver_in_repo):
      print >>sys.stderr, "Release %s does not seem to be a limited release." % release
      return None

    diffit_between_repo_and_ccs( workdir, rsync,  ccs_host, ccs_dir_root, ccsappname, latest_ver_in_repo, options )
    return None

  if options.force:
    reply = raw_input("Are you sure you know what you are doing? (y/n) ")
    reply = reply.strip()
    if reply.startswith('y'):
      diffit_between_repo_and_ccs( workdir, rsync,  ccs_host, ccs_dir_root, ccsappname, latest_ver_in_repo, options )
    return None

  latest_ver_in_ccs = get_latest_ver_in_ccs(ssh, sudo,  ccs_host, ccs_dir_root, ccsappname, options)

  if release.lower() == 'trunk':
    diffit_between_repo_and_ccs( workdir, rsync,  ccs_host, ccs_dir_root, ccsappname, latest_ver_in_ccs, options )
    return None

  if latest_ver_in_repo and  latest_ver_in_ccs and  int(latest_ver_in_ccs) == int(latest_ver_in_repo):
    diffit_between_repo_and_ccs( workdir, rsync,  ccs_host, ccs_dir_root, ccsappname, latest_ver_in_ccs, options )
  else: 
    print >>sys.stderr,  "WARNING: latest_ver_in_ccs:  %s !=  latest_ver_in_repo: %s for %s ... " % ( latest_ver_in_ccs, latest_ver_in_repo, ccsappname )


def  diffit_between_repo_and_ccs( workdir, rsync,  ccs_host, ccs_dir_root, ccsappname, latest_ver_in_ccs, options ):
  """
  now that we have workdir, e.g., ~/.diffit/CONFIG_R1040, we need to pull the dir structure from ccs server for ccsappname, then do the diff
  """  
  # pull it
  workdir_root = make_workdir_root()

  # remove the previously fetched dir to avoid dust 
  dir_to_remove = os.path.join(workdir_root, ccsappname)
  if os.path.isdir( dir_to_remove ):
    shutil.rmtree( dir_to_remove )

  cmd = "%s  --exclude '*Sensor*' %s:%s/%s/%s  %s/%s 2>/dev/null" % ( rsync, ccs_host, ccs_dir_root, ccsappname, '0.0.'+latest_ver_in_ccs, workdir_root, ccsappname ) 
  if options.verbose:
    print "INFO: pulling info from  %s:%s/%s/%s  " %  (ccs_host, ccs_dir_root, ccsappname, '0.0.'+latest_ver_in_ccs)
  if options.debug:
    print "INFO: Running cmd: %s " % cmd
  run_cmd( cmd )

  # diff it for extservices.springconfig
  env = Env(options.envname)
  fabric_name = env.get_fabric_name()  # e.g., STG-BETA, PROD-ELA4
  fabric_host_prefix = env.get_fabric_host_prefix()  # e.g., esv, ela4

####### this part is to treat cases where extservices.springconfig exists/not under ccsappname 
  if os.path.isfile( workdir+'/'+ccsappname+'/'+'extservices.springconfig' ):
    diff_from = "%s/%s/extservices.springconfig" % (workdir, ccsappname)
    diff_to = "%s/%s/%s/extservices.springconfig" % (workdir_root, ccsappname, '0.0.'+latest_ver_in_ccs)

#    cmd = "diff -w %s/%s/extservices.springconfig  %s/%s/%s/extservices.springconfig " % ( workdir, ccsappname, workdir_root, ccsappname, '0.0.'+latest_ver_in_ccs  )
    cmd = "diff -w %s %s" % (diff_from, diff_to)

    if options.verbose:
      print "INFO: diffing version level configs for %s:  %s (repo) <---> %s (ccs) " % (ccsappname, diff_from, diff_to)
    if options.debug:
      print "INFO: Running cmd: %s " % cmd
    run_cmd( cmd )
  else:
    print >>sys.stderr,  "WARNING: no version level config found for %s in SVN repo. " % ccsappname


  # diff it for dirs
  egrep_stuff = ' extservices.springconfig[._~-] '
  egrep_stuff_2 = ' "Common subdirectories:" '
  egrep_stuff_3 = ' "Only in .*: extservices.springconfig" '
  egrep_stuff_4 = ' ": container" '

  if os.path.isdir( workdir+'/'+ccsappname+'/'+ fabric_name ):
    diff_from = "%s/%s/%s" % (workdir, ccsappname, fabric_name)
    diff_to = "%s/%s/%s" % (workdir_root, ccsappname, '0.0.'+latest_ver_in_ccs)
    cmd = "diff -rw %s %s" % (diff_from, diff_to)
#    cmd = "diff -rw %s/%s/%s %s/%s/%s " \
#           % ( workdir, ccsappname, fabric_name, workdir_root, ccsappname, '0.0.'+latest_ver_in_ccs )
    cmd += " |  egrep -v %s  " % ( egrep_stuff )
    cmd += " |  egrep -v %s  " % ( egrep_stuff_2 )
    cmd += " |  egrep -v %s  " % ( egrep_stuff_3 )
    cmd += " |  egrep -v %s  " % ( egrep_stuff_4 )

    if options.verbose:
      print "INFO: diffing recursively for %s: %s (repo) <---> %s (ccs)  " %  (ccsappname, diff_from, diff_to)
    if options.debug:
      print "INFO: Running cmd: %s " % cmd
    run_cmd( cmd )

    # case: there is fabric_name, e.g., PROD-ELA4,  in repo, but there is no machine dirs in there,
    #        however we found machine dirs in ccs
    p = re.compile(r'.*%s' % fabric_host_prefix)
    possible_machine_dirs_in_repo = [ name for name in os.listdir(os.path.join(workdir, ccsappname, fabric_name)) if os.path.isdir(os.path.join(workdir, ccsappname, fabric_name, name)) and p.search(name) ]
    possible_machine_dirs_in_ccs = []
    if  os.path.exists(os.path.join(workdir_root, ccsappname)):
      if os.path.exists(os.path.join(workdir_root, ccsappname, '0.0.'+latest_ver_in_ccs)):
        possible_machine_dirs_in_ccs = [ name for name in os.listdir(os.path.join(workdir_root, ccsappname,'0.0.'+latest_ver_in_ccs)) if os.path.isdir(os.path.join(workdir_root, ccsappname,'0.0.'+latest_ver_in_ccs,name)) and p.search(name) ]
      else:
        print >>sys.stderr, "ALERT: not exists ", os.path.join(workdir_root, ccsappname, '0.0.'+latest_ver_in_ccs)
    else:
      print >>sys.stderr, "ALERT: not exists ", os.path.join(workdir_root, ccsappname)

    if options.debug:
      print 'fabric_host_prefix: ', fabric_host_prefix
      print os.listdir(os.path.join(workdir, ccsappname, fabric_name))
      print 'repo: ', possible_machine_dirs_in_repo
      print 'ccs: ', possible_machine_dirs_in_ccs 

    if not possible_machine_dirs_in_repo and possible_machine_dirs_in_ccs:
      print >>sys.stderr, "ALERT: machine level configs found for %s in CCS but not in SVN repo!" % ccsappname

  else:
    print >>sys.stderr, "INFO: no machine level and under configs found for %s in SVN repo. " % ccsappname
    # we should also handle the case where no machine level in repo, but machine level exists in CCS
    if options.debug:
      print 'fabric_host_prefix: ', fabric_host_prefix
      print os.listdir(os.path.join(workdir_root, ccsappname,'0.0.'+latest_ver_in_ccs))

    # case: no fabric_name, e.g., PROD-ELA4, under ccsappname in repo, but 
    #       found machine dirs in ccs
    p = re.compile(r'.*%s' % fabric_host_prefix)
    possible_machine_dirs = [ name for name in os.listdir(os.path.join(workdir_root, ccsappname,'0.0.'+latest_ver_in_ccs)) if os.path.isdir(os.path.join(workdir_root, ccsappname,'0.0.'+latest_ver_in_ccs,name)) and p.search(name) ]
    if possible_machine_dirs:
      print >>sys.stderr, "ALERT: machine level configs found for %s in CCS but not in SVN repo!" % ccsappname


def get_ccsappname_list( workdir,  release, options ):
  """
  get all apps with the ver # specified in the release in LATEST file in the workdir
  """
  apps = []
  for dirname, dirnames, filenames in os.walk( workdir ):
    for filename in filenames:
      if filename == 'LATEST':
        if not dirname == '.' and not  dirname == workdir :
          vernum = open( os.path.join(dirname, filename), "r" ).read().rstrip()
          # strip out R in say  R1040
          if vernum == release[1:]:
            #print "%s : %s" % (dirname, filename)
            apps.append(dirname.split('/')[-1])   # only need the dir name
  return apps


def __get_ccsappname_list( workdir,  release, options ):
  """
  get all apps under workdir, excluding EI*, STG*

  this is not currently used... too wide a range...
  """
  apps = []
  dirs_raw = os.listdir(workdir)

  apps = [ d for d in dirs_raw if not d == 'EI1' and not d == 'EI3' and not d == 'STG-ALPHA' and not d == 'STG-BETA'  ]

  return apps


def get_parser():
  usage = "usage: %prog [options] "
  parser = OptionParser(usage)
  parser.add_option("-e", "--env", dest="envname",
			help="[required] Environment name provided. supported ones: ei1, ei3,  stg, beta, ech3, ela4")
  parser.add_option("-f", "--file", dest="filename",
                        help="read data from FILENAME which contains on each line a ccs app name (aka, directory name in CCS), e.g., oms, webtrack, peopleSearchService etc.")
  parser.add_option("-r", "--release", dest="release",
			help="[required] Release#,  e.g., R1040, NOTE capital R! ")
  parser.add_option("-c", "--ccsapp", dest="ccsappname",
			help="The directory name in CCS  provided, e.g., should use auth rather than auth-server")
  parser.add_option( "-t", "--toplevel",  action="store_true",
            help="Use it to diff toplevel configs only")
  # deliberately force user to type more if they want to turn off toplevel sync
  parser.add_option(   "--notoplevel",  action="store_true",
            help="Use it to NOT diff toplevel configs  (read: no toplevel)")
  parser.add_option("-C", "--cleanup",  action="store_true",
			help="Use it to cleanup workdir" )
  parser.add_option("-l", "--limited", action="store_true", dest="limited",
            help="Use it to diff limited releases, e.g., [987]* releases."  )
  parser.add_option("-m", "--monolithic", action="store_true", dest="monolithic",
            help="Use it to diff monolithic releases, e.g., R1118 if current daily is R1114."  )
  parser.add_option( "--force", action="store_true", dest="force",
            help="Force it if you want to do upon an older release."  )
  parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=True,
			help="In verbose mode")
  parser.add_option("-d", "--debug", action="store_true", dest="debug",
			help="In debug mode")

  return parser


def cleanup_workdir( workdir, options ):
  shutil.rmtree( workdir )
  dot_dir = os.path.dirname(workdir)
  if options.debug:
    print "dot_dir : %s " % dot_dir
  shutil.rmtree( dot_dir )


def get_cfg2_comps( workdir ):
  cfg2_list = []
  cfg2_file = "%s/cfg2" % workdir
  if os.path.isfile( cfg2_file ):
    fh = open( cfg2_file, "r" )
    for line in fh:
      if line.strip():
        cfg2_list.append( line.strip() )
  return cfg2_list


def get_daily_release():
  fh = urllib.urlopen(url_to_current_daily_release_txt)
  daily = fh.read().strip()
  return daily

#  daily_file = os.path.join(os.environ['ITOPS_HOME'], 'ccs', 'bin', 'CURRENT_DAILY_RELEASE.txt')
#  with open(daily_file, 'r') as fh:
#    daily = fh.readline().strip()
#  return daily


def warning(msg, quit=False):
  print >>sys.stderr, "WARNING: " + msg
  if quit:
    return None


def get_containernames(path, ccsappname):
  # assumption: one name in dir
  # what happens if there are more names? error?
  # so it IS possible that there are more than 1 containers... here is the handle
  try:
    names = os.listdir(path)
  except OSError, e:
    warning("%s" % e)
    return None
  if not names:
    warning("Container info not in repo yet for %s" % ccsappname, quit=True)
  else:
    return names


def doit_for_one_servername(workdir, rsync, ccs_host, ccs_dir_root, ccsappname, options):
  # fetch from ccs, the repo counterpart already done in create_workdir
  workdir_root = make_workdir_root()
 
  # /export/content/repository/EI1  -> EI1
  ccs_dir_root_suffix = ccs_dir_root.split('/')[-1]

  repo_container_dir = os.path.join(workdir, ccsappname, ccs_dir_root_suffix, 'container')

  if not os.path.isdir(repo_container_dir):
    warning("No container path found in repo.") 

  # get container name: container/<container name>
  #  e.g., conatiner/auth-server
  # it's possible that there are more than 1 container names, e.g., 
  # leocs has cs-tomcat and 4cs-tomcat
  containernames = get_containernames(repo_container_dir, ccsappname)

  if not containernames:
    return None

  for containername in containernames:
    rsync_from = "%s:%s/%s" % (ccs_host, ccs_dir_root, containername)
    rsync_to = "%s/%s" % (workdir_root, 'container')
    rsync += " --exclude  '0.*' --exclude '*Sensor*' "
  
    cmd = "%s %s %s 2>/dev/null" % (rsync, rsync_from, rsync_to)
  
    if options.verbose:
      print "INFO: pulling container info from %s to %s" %  (rsync_from, rsync_to)
    if options.debug:
      print "INFO: running cmd: %s" % (cmd)
  
    run_cmd(cmd)
  
    # once we get from ccs, we can do diff now
    diff_repo = "%s/%s/%s/container/%s" % (workdir,  ccsappname, ccs_dir_root_suffix, containername) 
    diff_ccs =  "%s/container/%s" % ( workdir_root, containername)
  
    cmd = "diff -w %s %s " % (diff_repo, diff_ccs)
  
    # egrep filters
    egrep_filter_1 = ' "Common subdirectories:" '
    egrep_filter_2 = ' server_conf.sh[._~-] '
    egrep_filter_3 = ' server.xml[._~-] '
    egrep_filter_4 = ' ": extservices.springconfig" '
  
    cmd += " | egrep -v %s " % ( egrep_filter_1 )
    cmd += " | egrep -v %s " % ( egrep_filter_2 )
    cmd += " | egrep -v %s " % ( egrep_filter_3 )
    cmd += " | egrep -v %s " % ( egrep_filter_4 )
  
    if options.verbose:
      print "INFO: diffing containers  %s (repo) with  %s (ccs)" %  (diff_repo, diff_ccs)
    if options.debug:
      print "INFO: running cmd: %s" % (cmd)
    
    run_cmd(cmd)
  


  

########## main()
def main():
  parser = get_parser()
  options, args = parser.parse_args()

  if (options.toplevel and options.ccsappname) or (options.toplevel and options.filename):
    print >>sys.stderr, "ERROR: -t and -f or -t and -c  are mutually exclusive."
    parser.print_help()
    sys.exit(1)

  if options.toplevel and options.notoplevel:
    print >>sys.stderr, "ERROR: -t and --notoplevel are mutually exclusive."
    parser.print_help()
    sys.exit(1)

  if options.notoplevel:
    options.toplevel = False

  if options.filename and options.ccsappname:
    print >>sys.stderr, "ERROR: -c and -f are mutually exclusive."
    parser.print_help()
    sys.exit(1)

  # required:  options.envname
  if options.envname == None:
    print >>sys.stderr, "ERROR: I need an envname, e.g., beta"
    parser.print_help()
    sys.exit(1)

  # required:  options.release
  if options.release == None:
    print >>sys.stderr, "ERROR: I need a release, e.g., R1040"   
    parser.print_help()
    sys.exit(1)

  env = Env(options.envname) 
  env.check_envname_given()
  ccs_host = env.get_ccs_host()
  ccs_dir_root =  env.get_ccs_dir_root()
  if ccs_host == None or ccs_dir_root == None:
    print >>sys.stderr, "ERROR: I did not find ccs_host or ccs_dir_root."
    sys.exit(1)

  global debug
  debug = options.debug

  release = options.release
  release = release.upper()
 
  daily_release = get_daily_release()

  if options.debug:
#    print "ccsappname: " + ccsappname
    print "ccs_host: " +  ccs_host
    print "ccs_dir_root: " +  ccs_dir_root 
    print "relase: " +   release
    print "current_daily_relase: " +  daily_release

  if options.toplevel and options.release != daily_release:
    print >>sys.stderr, "ERROR: toplevel diff is only done for daily release branch. Currently it's: %s\n" % daily_release 
    sys.exit(1) 

  # semantic change for -r Rxxxx: 
  #  always create workspace on daily release, and diff between it and the ccs dir specified by -r Rxxxx
  workdir = create_workdir( daily_release, svn, ccs_dir_root, options ) 
  
  if not options.toplevel:
    ccsappname_list = []
    if options.filename:
      try:
        fh = open(options.filename, "r")
        for line in fh:
          if line.strip():
            ccsappname_list.append( line.strip() )
      except IOError:
        print >>sys.stderr, "ERROR: File %s does not exist!" % options.filename
        sys.exit(1)
    elif options.ccsappname:
      ccsappname_list.append( options.ccsappname )
    else:
      # if no -c and no -f provided, we'll look for LATEST file in workdir for ccsappname_list
      if options.verbose:
        print "INFO: using LATEST file on the branch to determine ccsappname_list."
      try:
        fh = open(workdir + '/LATEST', "r")
        for line in fh:
          if line.strip():
            ccsappname_list.append( line.strip() )
      except IOError:
        print >>sys.stderr, "ERROR: File %s does not exist!" %  workdir+'/LATEST'
        sys.exit(1)
  
    ccsappname_list_cfg2  = get_cfg2_comps( workdir )

  # only diff top level extservices and injected properties for daily release 
  #
  # feature creep: need to turn off toplevel sync by user
  #
  if release == daily_release and not options.notoplevel:
    doit_for_toplevel(release, svn, workdir,  ssh, rsync,  ccs_host, ccs_dir_root, options)

  if options.toplevel:
    sys.exit(0)

  for ccsappname in ccsappname_list:
    if options.verbose:
      print '-' * 80
      print "INFO: dealing with %s... " % ccsappname
    # no need to do cfg2 comps
    if  ccsappname_list_cfg2 and ccsappname  in ccsappname_list_cfg2:
      print >>sys.stderr, "WARNING: %s is in cfg2, no need to sync it to CCS server." % ccsappname
      continue
    else:
      doit_for_one(release, svn, workdir,  ssh, sudo,  ccs_host, ccs_dir_root, ccsappname, options)
      ###########################################################################
      #                              ACTION TABLE
      ###########################################################################
      #              Limited Release  |   Daily Release  |  Monolithic Release
      #  toplevel         x                   \/                  x
      #  app              \/                  \/                  \/
      #  server*          \/                  \/                  \/
      ###########################################################################
      doit_for_one_servername(workdir, rsync, ccs_host, ccs_dir_root, ccsappname, options)

  if options.cleanup:
    cleanup_workdir( workdir, options )

  # we are done here
  sys.exit(0)



if __name__ == "__main__":
    main()

