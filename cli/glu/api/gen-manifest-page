"""
Using GLU API to generate manifest
"""
#
# NOTE: no need to look for Flask install, just remember to run: python setup install_deps under ops-utils 
#
from flask import Flask, request
app = Flask(__name__)

from collections import defaultdict

import foobar.constants
import foobar.tools.glu
import foobar.tools.product
import foobar.utils.seq

PROD_ENVS = ['ech3', 'ela4']

@app.route('/')
def main():
#  fabric_name = 'STG-BETA'
  fabric_name =  None
  env_name = request.args.get('env', '')
  html = ''
  if not env_name:
    html += 'Please provide a valid env name using ?env=&lt;valid_env_name&gt; <p />'
    html += 'For example, here is a link to: <a href="?env=beta"> beta  </a> <p />'
    html += 'Valid env names are: <p />'
    all_envnames = foobar.constants.FABRIC_MAP.keys()
    for n in all_envnames:
      html += '%s <br />' % n
    return html

  fabric_name = foobar.constants.FABRIC_MAP[env_name]
 
  fabric = foobar.tools.fabric.Fabric(fabric_name)
  html = "<h1>Showing Manifest for: "  + fabric_name + '</h1>'
  html += '<p /><p />'
  html += '<table border="1">'

  # table header
  html += '<tr bgcolor="green"><th> Product </th><th> Service Name </th><th> Container Name </th><th> Context Path </th><th> Port  </th><th> WAR(s) </th><th> Host(s) </th>'

  wars_of = defaultdict(list)
  hosts_of = defaultdict(list)
  port_of = defaultdict()
  jmx_port_of = defaultdict()
  product_of = defaultdict()
  service_of = defaultdict()
  context_of = defaultdict()
  
  # FEs have different way of presenting logs/jmx links
  logs_str_of = defaultdict()
  jmx_str_of = defaultdict()

  # actually all service names
  all_services = [ i.container.name for p in fabric.products for s in p.services for i in s.instances ]

  # Sort the results so things are generally consistent
  all_services = foobar.utils.seq.unique(all_services)
  all_services.sort()

  for p in fabric.products:
    for s in p.services:
      for i in s.instances:
        warname = i.coordinates.split('/')[-2]
        host = i.host.name
        cname = i.container.name  # cname: service instance container name
        port_of[cname] = i.port
        jmx_port_of[cname] = i.port
        product_of[cname] = s.product.name
        service_of[cname] = s.name
        if s.context:
          context_of[cname] = s.context
        else:
          context_of[cname] = ''

        # BE is simpler
        logs_str_of[cname] = 'logs'
        jmx_str_of[cname] = 'jmx'

        if i.is_frontend():
          port_of[cname] = 12900
          jmx_port_of[cname] = 12001
          new_str = cname.replace('-tomcat','')

          # while FE is a bit more complicated....
          # TODO:  potential trap here:  what happens if a FE is not named xxxx-tomcat? Oooops..... broken here then 
          
          logs_str_of[cname] = '%s/logs' % new_str
#          jmx_str_of[cname] = '%s/jmx' % new_str

        if warname not in wars_of[cname]:
          wars_of[cname].append(warname)
        if host not in hosts_of[cname]:
          hosts_of[cname].append(host)

  for s in all_services:
    wars_of[s] = foobar.utils.seq.unique(wars_of[s])
    wars_of[s].sort()

    hosts_of[s] = foobar.utils.seq.unique(hosts_of[s])
    hosts_of[s].sort()

    str_wars = ''
    for w in wars_of[s]:
      str_wars += w + ' '
    str_hosts = ''
    for h in hosts_of[s]:
      if env_name not in PROD_ENVS:
        logs_link = "<a href='http://%s.foobar.com:%s/%s'> logs </a>" % (h, port_of[s], logs_str_of[s])
        jmx_link = "<a href='http://%s.foobar.com:%s/%s'> jmx </a>" % (h, jmx_port_of[s], jmx_str_of[s])
        str_hosts += h + '(' + logs_link + ', ' +  jmx_link + ') ' 
      else:
        str_hosts += h + ' '
   
    html += '<tr><td>' + product_of[s] + '</td><td>' + service_of[s] + '</td><td>' + s + '</td><td>' + context_of[s] +  '</td><td>' + str(port_of[s]) + '</td><td>' + str_wars + '</td><td>' + str_hosts + '</td></tr>'

  html += '</table>'

  return html

if __name__ == "__main__":
  app.run(host='0.0.0.0', port=8888, debug=True)

