#!/export/apps/splunk/i001/splunk/bin/python
#
# lwang: This script is to automate glu console backup
#
#	./scr -h
#
# Assumption:
#============
#  * the backup dir name must be: DB_backup
#
import sys
import os
import re
import time
import subprocess
from optparse import OptionParser
from socket import gethostname
import atexit

ssh = '/bin/ssh'
sudo = '/usr/local/bin/sudo'


GLU_CONSOLE_HOST_OF = {
  'ei3'  : 'esv4-fe08.corp',
  'stg'  : 'gluconsole.corp',
  'ech3' : 'ech3-glu01.prod',
  'ela4' : 'ela4-glu03.prod',
}

TOPDIR_OF = {
  'ei3'  : '/export/content/glu/console',
  'stg'  : '/export/content/glu_console/stg',
  'ech3' : '/export/content/glu_console/prod-ech3',
  'ela4' : '/export/content/glu_console/prod-ela4',
}



##############################################################
  
def warmup_sudo(ssh, host, sudo):
  prompt = "Enter password (kerberos): "
  pwd = getpass(prompt)
#  print pwd
  print "\n"
  cmd = "echo %s | %s %s ' %s ls >/dev/null 2>&1 ' 2>/dev/null " % ( pwd, ssh, host, sudo ) 
  print "INFO: running warmup_sudo"

  run_cmd( cmd )


def getpass(prompt="Enter password (kerberos): "):
  import termios
  fd = sys.stdin.fileno()
  old = termios.tcgetattr(fd)
  new = termios.tcgetattr(fd)
  new[3] = new[3] & ~termios.ECHO   # lflags
  try:
    termios.tcsetattr(fd, termios.TCSADRAIN, new) 
    passwd = raw_input(prompt)  
  finally:
    termios.tcsetattr(fd, termios.TCSADRAIN, old) 
  return passwd


def run_cmd( cmd, debug=False ):
  if debug:
    print "running cmd: " + cmd
  try:
    retcode = subprocess.call( " %s " % cmd, shell=True )
    if retcode < 0:
      print >>sys.stderr, "Child was terminated by signal", -retcode      
#    else:
#      print >>sys.stderr, "Child returned", retcode      
  except OSError, e:
    print >>sys.stderr, "Execution failed: ", e


def manage_service(action, ssh, host, sudo, topdir, options):
  cmd = "%s -q  %s ' cd %s; %s ./bin/server.initd %s' " % (ssh, host, topdir, sudo, action)  

  if options.debug:
    print "Running cmd: " + cmd

  if options.verbose:
    print "INFO: %s service..." % action

  if options.execute:
    run_cmd( cmd )


def kill_pid(this_pid, ssh, host, sudo, topdir, options):
  cmd = "%s -q  %s ' %s kill -9 %s' " % (ssh, host, sudo, this_pid)  

  if options.debug:
    print "Running cmd: " + cmd

  if options.verbose:
    print "INFO: killing pid %s ..." %  this_pid

  if options.execute:
    run_cmd( cmd )


def check_pid(ssh, host, sudo, topdir, options):
  cmd = "%s  -q %s ' cd  %s;  %s pargs `/bin/cat logs/catalina.pid` ' >/dev/null 2>&1  " % (ssh, host, topdir, sudo)
#  cmd = "%s  -q %s ' cd  %s;  /bin/cat /export/home/lwang/foobar'  " % (ssh, host, topdir  )
  if options.debug:
    print "Running cmd: " + cmd

  retcode  = subprocess.call(cmd, shell=True)
  # if retcode != 0, then proc is done
  if retcode:
    print "proc gone, next play..."
    return None
  # if retcode == 0, then proc still running
  else:
    print "proc still running..."
    return retcode

  
def doit(ssh, host, sudo, topdir, options):
  time_str = time.strftime('%Y%m%d%H%M%S', time.localtime())
  cmd = "%s -q  %s ' cd %s; %s cp prodDb.script DB_backup/prodDb.script.%s  ; %s cp prodDb.properties DB_backup/prodDb.properties.%s ' " % (ssh, host, topdir, sudo, time_str, sudo, time_str )

  if options.debug:
    print "Running cmd: " + cmd

  if options.execute:
    run_cmd( cmd )


def double_check(ssh, host, sudo, topdir, options):
  pass


def do_backup(ssh, host, sudo, topdir, options):
  if options.verbose:
    print >>sys.stderr, "Backing up GLU Console DB for %s on %s" % (options.envname, host)

  # stop service 
  manage_service('stop', ssh, host, sudo, topdir, options) 

  # check and wait for pid to go away
  print "Checking pid, do hard kill if necessary..."
  if options.execute:
    # check pid, do hard-kill if necessary
    # check pid file  every 5 seconds for 10 minutes maximum
    sleeptime = 5
    duration = 600  # 10 minutes  = 600 seconds
    while True:
      ret = check_pid(ssh, host, sudo, topdir, options)
      if ret is None:  # if ret is None, it means the proc is gone 
        break
      # otherwise, sleep and try again, until we run out of duration, at which point, do kill_pid
      print 'sleep %d sec | duration %d sec' % (sleeptime, duration)
      time.sleep(sleeptime)
      duration -= 5
      if duration < 0:
        # ret is the pid, now that it's not None
        # once pid is killed, move on
        kill_pid(ret, ssh, host, sudo, topdir, options)
        break
    
  # do backup
  doit(ssh, host, sudo, topdir, options)

  # start service 
  manage_service('start', ssh, host, sudo, topdir, options) 

  # check really backed up
  double_check(ssh, host, sudo, topdir, options)



########## main()
def main():
  usage = "usage: %prog [options] "
  parser = OptionParser(usage)
  parser.add_option("-e", "--env", dest="envname",
			help="[required] Environment name provided. supported ones: ei3, stg, ech3, ela4")
  parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
			help="In verbose mode")
  parser.add_option("-d", "--debug", action="store_true", dest="debug",
			help="In debug mode")
  parser.add_option( "-E", "--execute",  action="store_true",
			help="Use it when you are ready to __execute__ it")

  (options, args) = parser.parse_args()

  # should only be run on rotozip
  hostname = gethostname()
  if hostname != 'rotozip.corp':
    print >>sys.stderr, "ERROR: run the script on rotozip."
    sys.exit(1)

  # required:  options.envname
  if options.envname == None:
    print "ERROR: I need an envname, e.g., stg"
    parser.print_help()
    sys.exit(1)

  glu_console_host = GLU_CONSOLE_HOST_OF[options.envname]
  topdir  = TOPDIR_OF[options.envname]

  if options.debug:
    print "glu_console_host: ", glu_console_host 
    print "topdir: ", topdir  


  if options.execute:
    warmup_sudo(ssh, glu_console_host, sudo)

  do_backup(ssh, glu_console_host, sudo, topdir, options)


if __name__ == "__main__":
    main()

