#!/bin/env perl 
#
# lwang: Fetch public_access log from the first machine for one app or all apps ( --app | -a  <appname> ) 
#
# usage:
#
#	 ./fetcher.pl  
#  -or- 
#	 ./fetcher.pl  -help
#

use warnings;
use strict;

use Getopt::Long;

use POSIX 'WNOHANG';
$SIG{CHLD} = sub { while( waitpid(-1, WNOHANG)  > 0 ) { } };

my $help;
my $debug;
my $app;
my $execute;
my $start;	# start time stamp
my $end;	# end time stamp
my $parallel;	# parallel degree
my $file;	# file containing apps interested
my $perl = "/bin/perl";
my $gtar = "/usr/sfw/bin/gtar";
my $ssh = "/bin/ssh";
my $scp = "/bin/scp";
my $env;
my $outdir;	# where you want to put the logs
my $user;	# do ssh as user, otherwise as whoever runs the scr 
my $allmachines;	# not just get the first machine, but all machines for an app 
my $noemail;		# do not send out email
my $perftest;		# drop on to perftest machines

my $deft_parallel = 1;  	# default parallel degree

my $perftest_allocation_limit = 150; 	# this is the max number of log files each perftest machine is allocated
my %perftest_allocation;		# this is the global hash to keep track of the number of allocated log files for each perftest machine:
					#	perftest_machine => count

# need ITOPS_HOME env var to run 
die "Please have your ITOPS_HOME environment variable set.\n" unless $ENV{ITOPS_HOME};
chomp(my $itops_home =  $ENV{ITOPS_HOME});


GetOptions(
	"user=s" => \$user,
	"outdir=s" => \$outdir,
	"file=s" => \$file,
	"parallel=s" => \$parallel,
	"start=s" => \$start,
	"end=s" => \$end,
	"env=s" => \$env,
	"app=s" => \$app,
	"allmachines" => \$allmachines,
	"noemail" => \$noemail,
	"perftest" => \$perftest,
	"help" => \$help,
	"debug" => \$debug,
	"execute" => \$execute,
);

my $usage =<<USAGE;

Usage:

  $0 	{ [ --app | -a  <appname> ] | [ --file | -f <file> ]  } { --env | -env <env> } 
	{ --start <start time stamp> } {  --end <end time stamp> }  
	--outdir <output dir location> --parallel <parallel degree>  --user <user>
	--allmachines --noemail --perftest ---debug --help --execute

Examples:

	\$  $0 --env ech3  --app auth-server --start '2009/11/02 07:05'  --end '2009/11/02 14:18' --execute
		: fetch public_access log for auth-server only, in the time window specified, and put them in the default drop dir: Hari's public folder

	\$  $0 --env ech3  --app all  --start '2009/11/02 07:05'  --end '2009/11/02 14:18' --outdir ~/mylogs --execute
		: fetch public_access logs for all apps in manifest_ech3,  in the time window specified, and put them in ~/mylogs

	\$  $0 --env stg  --app all  --start '2009/11/02 07:05'  --end '2009/11/02 14:18' --outdir ~/mylogs --execute
		: fetch public_access logs for all apps in manifest_stg,  in the time window specified, and put them in ~/mylogs

	\$  $0 --env stg  --app all  --start '2009/11/02 07:05'  --end '2009/11/02 14:18' --outdir ~/mylogs --user lwang --execute
		: fetch public_access logs for all apps in manifest_stg,  in the time window specified, and put them in ~/mylogs, using credential of user lwang



NOTES: 	* The minute part in the timestamp is ignored for now. e.g., -start '2009/11/02 07:05' -end '2009/11/02 14:18' is the same as -start '2009/11/02 07:00' -end '2009/11/02 14:00' 
          which means fetching lines with time from '2009/11/02 07:00' to '2009/11/02 14:59'

	* Default parallel degree is: $deft_parallel

	* Default <login_name> is whoever runs the script
	
	* By default, we only get the first machine, but --allmachines can be used to get all machines


USAGE


#if ( $help  or @ARGV == 0 ) {
if ( $help or ! ( $app || $file ) ) {
  print $usage;
  exit;
}

if ( ! $start || ! $end  || ! $env ) {
  print $usage;
  exit;
}

if ( $app and $file ) {
  print "\n--app and --file are mutually exclusive.\n";
  print $usage;
  exit;
}



$parallel = $parallel ? $parallel : $deft_parallel;  # give a default parallel degree: $deft_parallel 

print "parallel degree: $parallel\n" if $debug;


chomp (my $starttime = `date +%Y%m%d_%H%M%S` );

# globals
my $default_drop_dir_root = "/Volumes/Staff/Mountain View/Haricharan Ramachandra/Public/log_fetching";

if ( $perftest ) {
  $default_drop_dir_root = "/export/home/tester/log_fetching";
}

my $drop_dir_root = $outdir ? $outdir :  $default_drop_dir_root;


my @perftest_machines = qw( 
  perftest6.qa
  perftest7.qa
  perftest8.qa
  perftest9.qa
);
  



# now that we have the drop dir, mkdir a sub dir
chomp( my $me = `whoami`);
chomp( my $time_stamp = `date +%Y%m%d_%H%M%S`);
print "time_stamp: $time_stamp \n" if $debug;
print "me: $me \n" if $debug;
print "env: $env \n" if $debug;

my $runas = $user ? $user : $me;

my $work_dir = "${time_stamp}_${me}_${env}";

print "work_dir: $work_dir \n" if $debug;



if ( $perftest ) {

  print "Creating $drop_dir_root on perftest machines: @perftest_machines. \n" if $debug;
  foreach my $m ( @perftest_machines ) {
    my $cmd = qq[$ssh tester@$m "mkdir -p $drop_dir_root/$work_dir" ];
    do_cmd( $cmd );
  }

} 
else {

  #die "\nOops.... Please connect to server smb://dfs.foobar.biz and mount the volume \"Staff\" first. \n\n" unless -d "$drop_dir_root";
  die "\nOops.... I cannot find: $drop_dir_root, or it's not writable by you.  \n\n" unless -w "$drop_dir_root";

  umask 0022;
  mkdir "$drop_dir_root/$work_dir" if $execute;

}



# now get to work...



if ( $app &&  $app ne 'all'  ) {

    doit( $app );

#  my $m = get_first_machine( $app );
#  print STDERR "\nINFO: fetching log for $app on $m\n" if $debug ;
#  fetch_log( $app, $m);

  exit;

} 
elsif ( $file ) {

  my @apps;

  # if -file is provided, get all apps from the file
  print "Reading apps from file: $file...\n" if $debug; 

  open my $f, "<", $file or die "Cannot open file $file for reading: $!\n";
  while (<$f>) {
    chomp;
    next if /^\s+$/;
    s/\s+$//;
    push @apps, $_;
  }
  close $f;

  print "Dealing apps: ===@apps===\n" if $debug;

  do_it_in_parallel( @apps );


}
else {

  my $apps = `$itops_home/bin/cmtool.pl -a get_pools -env $env`;
  
  my @apps = split(" ", $apps);
  
  do_it_in_parallel( @apps );

  
}


send_email() unless $noemail;

exit(0);


sub do_it_in_parallel {

  my @apps = @_;

  if (  @apps < $parallel ) {
    do_chunk(  \@apps  );
  }
  else {

    my @chunks;  # array of refs to arrays: [ [...], [...] ... ]
    push @chunks, [ splice @apps, 0, $parallel ] while @apps;
  
    for my $chunk ( @chunks ) {
      print "\nDealing with chunk: @$chunk\n";
      print scalar @$chunk, "\n";
  
      do_chunk( $chunk ) ;
  
    }
  
  }

}

sub do_chunk {

  my $ref_chunk = shift;

  my @chunk = @$ref_chunk;

  my @childs;

  for ( 1..@chunk ) {
  
      my $pid = fork();
  
      if ($pid) {
  
        # parent
        push(@childs, $pid);
  
      } elsif ($pid == 0) {
  
        # child
        print "in child: $_ ( $chunk[$_-1] )\n\n";
        # sleep 5;
        doit( $chunk[$_-1] );
        exit(0);
  
      } else {
  
        die "couldn't fork: $!\n";
  
      }
  
  }
  
  foreach (@childs) {
    waitpid($_, 0);
  }
  
}

sub do_machines_in_parallel {
  my $app = shift;
  my $ref_machines = shift;

  my @machines = @$ref_machines;

  my @childs;

  foreach my $m ( @machines ) {
    my $pid = fork();
    if ( $pid ) {
      push @childs, $pid;
    }
    elsif ( $pid == 0 ) {
      print "in do_machines_in_parallel, doing $app on $m.\n";
      fetch_log( $app, $m );
      exit(0); 
    }
    else {
      die "couldn't fork in do_machines_in_parallel: $!\n";
    }
  }

  foreach ( @childs ) {
    waitpid($_, 0);
  }

}


sub doit {

  my $app = shift;

  return if $app =~ /^memcache/;

  if ( $allmachines ) {
    # do machines in parallel
    my @machines = get_all_machines_of( $app);
    do_machines_in_parallel($app, \@machines);

  }
  else {
    my $m = get_first_machine ( $app );

    print "\nINFO: fetching log for $app on $m\n" if $debug ;

    fetch_log( $app, $m);

  }
}


sub send_email {

  # send email when done
  # hramachandra@foobar.com
  # echo "/Volumes/Staff/Mountain View/Haricharan Ramachandra/Public/log_fetching/20091028_lwang/" | mailx -s "log download is done, please check ..." lwang@foobar.com
  
  chomp (my $endtime = `date +%Y%m%d_%H%M%S` );
  
  my $subject = "log download is done, please check ...";
  my $msg = "$drop_dir_root/$work_dir/\n\nStarting: $starttime\nEnding: $endtime\n" ;
  $msg .= "\n\n@perftest_machines\n" if $perftest;
  my $ccusers = "lwang\@foobar.com,siteops_release\@foobar.com";
  my $tousers = "hramachandra\@foobar.com es-performance\@foobar.com";
  
  #| mailx -s "$subject" -c lwang@foobar.com  lwang@foobar.com ];
  
  my $cmd = qq[ echo  "$msg" |  mailx -s "$subject" -c $ccusers $tousers ];
  
  print "Running: $cmd\n" if $debug;
  system( $cmd) if $execute;

}


sub get_all_machines_of  {
  my $app = shift;
  my $hosts = `$itops_home/bin/cmtool.pl -a get_pool_hosts -env $env -pool $app`;
  my @hosts = split(" ", $hosts);

  @hosts;

}


sub get_first_machine {
  my $app = shift;
  my $hosts = `$itops_home/bin/cmtool.pl -a get_pool_hosts -env $env -pool $app`;
  my @hosts = split(" ", $hosts);

  #
  # ugly special cases... yucky
  #
  if ( $app eq 'nus' && $env eq "ech3"  ) {
    'ech3-cdn31.prod';
  } 
  else {
    $hosts[0];
  }
}


sub fetch_log {
  my $a = shift;
  my $m = shift;

  my $p = get_path($a);

#  my $cmd = qq[ ssh $m " ls -l /export/content/$p/i001/conf/server_conf.sh  " 2>/dev/null ];
#  my $cmd = qq[ ssh $m " ls -l /export/content/$p/i001/logs/*public_access.log  " 2>/dev/null ];

  # it's possible that there exist  more than one public_access files 
  chomp(my @logfile_path = `$ssh  $runas\@$m "ls -1 /export/content/$p/i001/logs/*public_access.log" 2>/dev/null` );

  if ( @logfile_path > 1 ) {

    # get filtered log file

    foreach my $logfile_path ( @logfile_path ) {
      fetch_filtered_logfile( $logfile_path, $m );
    }

  }
  elsif (  @logfile_path == 1  ) {

    my $logfile_path = shift @logfile_path;

    fetch_filtered_logfile( $logfile_path, $m );

  }
  else {
    print "\n****** No public_access file found for $a on $m\n\n";
  }

}


sub get_path {
  my $a = shift;
  my $p = $a; # by default

#  system("./is_front_end_webapp $a");

#  if ( `egrep '^$a      ' $itops_home/manif/container_mapping_ech3` ) {
#chomp(    $p = `cat $itops_home/manif/container_mapping_ech3 | egrep '^$a        ' | cut -f2 `     ) ; 
#  }

  open my $f, "<", "$itops_home/manif/container_mapping_${env}" or die "Cannot open file $itops_home/manif/container_mapping_${env}: $!\n";
  while (<$f>) {
    chomp;
    $p = $1 if /^$a\t(.*)/;
  }
  close $f;

  $p;

}

sub fetch_filtered_logfile {

  my $logfile_orig = shift;
  my $m = shift;
  my $cmd;

  my $logfile = $1 if $logfile_orig =~ m{.*/(.*)};
  my $logfile_filtered = "$logfile";
  my $logfile_filtered_tgz = "${logfile}.tgz";

  # push the filter script to remote host
  $cmd = qq[ $scp filter.pl $runas\@$m:~  ];
  do_cmd ( $cmd );

  # create logfile_filtered
  $cmd = qq[ $ssh -l $runas $m "cd ~; $perl filter.pl '$start' '$end'  $logfile_orig  $logfile_filtered " ];
  do_cmd ( $cmd );

  # gtar
  $cmd = qq[ $ssh -l $runas $m "cd ~; $gtar czf $logfile_filtered_tgz  $logfile_filtered"  ];
  do_cmd ( $cmd );

  # fetch the filtered logfile
  unless ( $perftest ) {
    $cmd = qq[ $scp $runas\@$m:~/$logfile_filtered_tgz  "$drop_dir_root/$work_dir/${m}_${logfile}.tgz" ];
    do_cmd ( $cmd );
  }
  else {
    # if we are asked to drop to pertest machines...
    # 
    # Current implementation: 
    #   use a global hash to keep track of how many logs have been allocated to which perftest machine
    # 
    while ( my $pm  = pop @perftest_machines ) {
      if ( $perftest_allocation{$pm} < $perftest_allocation_limit ) {
        print "inc on $pm \n";
        $cmd = qq[ $scp $runas\@$m:~/$logfile_filtered_tgz  tester@$pm:$drop_dir_root/$work_dir/${m}_${logfile}.tgz ];
        do_cmd ( $cmd );
        $perftest_allocation{$pm}++; 
        last;
      } 
      else {
        next;
      }
    }

  }


}

sub do_cmd {
  my $cmd = shift;

  print $cmd, "\n" if $debug;
  system( $cmd ) if $execute;

}



